require Math;
require FabricOGL;

object SpliceStandaloneCamera {
  Vec3 position;
  Vec3 target;
  Float32 nearValue;
  Float32 farValue;
  Float32 fovY;

  Vec3 velocity;
  Float32 velocitySpeed;
  Float32 velocityBlend;
  Float32 velocityDrag;
};

function SpliceStandaloneCamera() {
  this.nearValue = 0.01;
  this.farValue = 1000.0;
  this.fovY = 50.0 * DEG_TO_RAD;
  this.velocitySpeed = 1.5;
  this.velocityBlend = 0.1;
  this.velocityDrag = 0.97;

  this.resetPosition();
}

function Mat44 SpliceStandaloneCamera.getMatrix!() {

  Xfo xfo;
  xfo.sc = Vec3(1, 1, 1);
  xfo.ori.setFromDirectionAndUpvector(this.position - this.target, Vec3(0, 1, 0));

  Vec3 velocity;
  velocity += this.velocity.x * xfo.ori.getXaxis();
  velocity += this.velocity.y * xfo.ori.getYaxis();
  velocity += this.velocity.z * xfo.ori.getZaxis();
  this.position += velocity;
  this.target += velocity;

  this.velocity *= this.velocityDrag;
  if(this.velocity.lengthSquared() < 0.01)
    this.velocity = Vec3(0.0, 0.0, 0.0);

  xfo.ori.setFromDirectionAndUpvector(this.position - this.target, Vec3(0, 1, 0));
  xfo.tr = this.position;

  return xfo.toMat44();
}

function SpliceStandaloneCamera.walk!(Float32 x, Float32 y, Float32 z) {
  Vec3 newVelocity(x, y, z);
  this.velocity = this.velocity.linearInterpolate(newVelocity * this.velocitySpeed, this.velocityBlend);
}

function SpliceStandaloneCamera.orbit!(Vec2 move) {

  Vec3 diff = this.position - this.target;
  Vec3 zAxis = diff.unit();

  Vec3 yAxis = Vec3(0, 1, 0);
  Vec3 xAxis = yAxis.cross(zAxis);

  Quat q;
  q.setFromAxisAndAngle(yAxis, move.x);
  diff = q.rotateVector(diff);
  q.setFromAxisAndAngle(xAxis, move.y);
  diff = q.rotateVector(diff);

  this.position = this.target + diff;
}

function SpliceStandaloneCamera.pan!(Vec2 move) {

  Vec3 diff = this.position - this.target;
  Vec3 zAxis = diff.unit();

  Vec3 yAxis = Vec3(0, 1, 0);
  Vec3 xAxis = yAxis.cross(zAxis);
  yAxis = xAxis.cross(zAxis);

  xAxis *= diff.length() * 0.1 * move.x;
  yAxis *= diff.length() * 0.1 * move.y;

  this.position += xAxis + yAxis;
  this.target += xAxis + yAxis;
}

function SpliceStandaloneCamera.dolly!(Scalar move) {

  Vec3 diff = this.position - this.target;
  Scalar length = diff.setUnit();
  length *= 1.0 + move;
  if(length < 0.01)
    length = 0.01;

  this.position = this.target + diff * length;
}

function SpliceStandaloneCamera.frameBBox!(Box3 bounds) {

  Vec3 center = (bounds.min + bounds.max) * 0.5;
  Vec3 targetDiff = center - this.target;
  this.target += targetDiff;
  this.position += targetDiff;
  Vec3 posDiff = this.target - this.position;

  Vec3 x = posDiff;
  x = x.cross(Vec3(0, 1, 0));
  x = x.cross(posDiff).unit();

  Scalar maxDot = 0.0;
  Vec3 corners[8];
  corners[0] = Vec3(bounds.min.x, bounds.min.y, bounds.min.z);
  corners[1] = Vec3(bounds.max.x, bounds.min.y, bounds.min.z);
  corners[2] = Vec3(bounds.min.x, bounds.max.y, bounds.min.z);
  corners[3] = Vec3(bounds.min.x, bounds.min.y, bounds.max.z);
  corners[4] = Vec3(bounds.max.x, bounds.max.y, bounds.min.z);
  corners[5] = Vec3(bounds.max.x, bounds.min.y, bounds.max.z);
  corners[6] = Vec3(bounds.min.x, bounds.max.y, bounds.max.z);
  corners[7] = Vec3(bounds.max.x, bounds.max.y, bounds.max.z);

  for(Size i=0;i<8;i++) {
    Scalar dot = abs(x.dot(center-corners[i]));
    if(dot > maxDot) maxDot = dot;
  }

  Scalar distance = maxDot / tan(this.fovY * 0.4);
  this.position = this.target - posDiff.unit() * distance;
}

function SpliceStandaloneCamera.resetPosition!() {
  this.position = Vec3(30, 20, 40) * 0.6;
  this.target = Vec3(0, 0, 0);
}