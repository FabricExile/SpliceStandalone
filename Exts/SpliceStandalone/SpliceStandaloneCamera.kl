require Math;
require FabricOGL;

object SpliceStandaloneCamera {
  Vec3 position;
  Vec3 target;
  Float32 nearValue;
  Float32 farValue;
  Float32 fovY;

  Vec3 walkVelocity;
  Float32 walkVelocitySpeed;
  Float32 walkVelocityBlend;
  Float32 walkVelocityDrag;
  Vec2 turnVelocity;
  Float32 turnVelocitySpeed;
  Float32 turnVelocityBlend;
  Float32 turnVelocityDrag;
};

function SpliceStandaloneCamera() {
  this.nearValue = 0.01;
  this.farValue = 1000.0;
  this.fovY = 50.0 * DEG_TO_RAD;
  this.walkVelocitySpeed = 1.5;
  this.walkVelocityBlend = 0.025;
  this.walkVelocityDrag = 0.995;
  this.turnVelocitySpeed = 1.5;
  this.turnVelocityBlend = 0.1;
  this.turnVelocityDrag = 0.95;

  this.resetPosition();
}

function Mat44 SpliceStandaloneCamera.getMatrix!() {

  Xfo xfo;
  xfo.sc = Vec3(1, 1, 1);
  xfo.ori.setFromDirectionAndUpvector(this.position - this.target, Vec3(0, 1, 0));

  Vec3 walkVelocity;
  walkVelocity += this.walkVelocity.x * xfo.ori.getXaxis();
  walkVelocity += this.walkVelocity.y * xfo.ori.getYaxis();
  walkVelocity += this.walkVelocity.z * xfo.ori.getZaxis();
  this.position += walkVelocity;
  this.target += walkVelocity;

  Quat turn;
  turn.setFromAxisAndAngle(Vec3(0, 1, 0), this.turnVelocity.x);
  this.target = this.position + turn.rotateVector(this.target - this.position);
  turn.setFromAxisAndAngle(Vec3(1, 0, 0), this.turnVelocity.y);
  this.target = this.position + turn.rotateVector(this.target - this.position);

  this.walkVelocity *= this.walkVelocityDrag;
  if(this.walkVelocity.lengthSquared() < 0.00001)
    this.walkVelocity = Vec3(0.0, 0.0, 0.0);

  this.turnVelocity *= this.turnVelocityDrag;
  if(this.turnVelocity.lengthSquared() < 0.00001)
    this.turnVelocity = Vec2(0.0, 0.0);

  xfo.ori.setFromDirectionAndUpvector(this.position - this.target, Vec3(0, 1, 0));
  xfo.tr = this.position;

  return xfo.toMat44();
}

function SpliceStandaloneCamera.walk!(Float32 x, Float32 y, Float32 z) {
  Vec3 newVelocity(x, y, z);
  this.walkVelocity = this.walkVelocity.linearInterpolate(newVelocity * this.walkVelocitySpeed, this.walkVelocityBlend);
}

function SpliceStandaloneCamera.turn!(Float32 x, Float32 y) {
  Vec2 newVelocity(x, y);
  this.turnVelocity = this.turnVelocity.linearInterpolate(newVelocity * this.turnVelocitySpeed, this.turnVelocityBlend);
}

function SpliceStandaloneCamera.orbit!(Vec2 move) {

  Vec3 diff = this.position - this.target;
  Vec3 zAxis = diff.unit();

  Vec3 yAxis = Vec3(0, 1, 0);
  Vec3 xAxis = yAxis.cross(zAxis);

  Quat q;
  q.setFromAxisAndAngle(yAxis, move.x);
  diff = q.rotateVector(diff);
  q.setFromAxisAndAngle(xAxis, move.y);
  diff = q.rotateVector(diff);

  this.position = this.target + diff;
}

function SpliceStandaloneCamera.pan!(Vec2 move) {

  Vec3 diff = this.position - this.target;
  Vec3 zAxis = diff.unit();

  Vec3 yAxis = Vec3(0, 1, 0);
  Vec3 xAxis = yAxis.cross(zAxis);
  yAxis = xAxis.cross(zAxis);

  xAxis *= diff.length() * 0.1 * move.x;
  yAxis *= diff.length() * 0.1 * move.y;

  this.position += xAxis + yAxis;
  this.target += xAxis + yAxis;
}

function SpliceStandaloneCamera.dolly!(Scalar move) {

  Vec3 diff = this.position - this.target;
  Scalar length = diff.setUnit();
  length *= 1.0 + move;
  if(length < 0.01)
    length = 0.01;

  this.position = this.target + diff * length;
}

function SpliceStandaloneCamera.frameBBox!(Box3 bounds) {

  Vec3 center = (bounds.min + bounds.max) * 0.5;
  Vec3 targetDiff = center - this.target;
  this.target += targetDiff;
  this.position += targetDiff;
  Vec3 posDiff = this.target - this.position;

  Vec3 x = posDiff;
  x = x.cross(Vec3(0, 1, 0));
  x = x.cross(posDiff).unit();

  Scalar maxDot = 0.0;
  Vec3 corners[8];
  corners[0] = Vec3(bounds.min.x, bounds.min.y, bounds.min.z);
  corners[1] = Vec3(bounds.max.x, bounds.min.y, bounds.min.z);
  corners[2] = Vec3(bounds.min.x, bounds.max.y, bounds.min.z);
  corners[3] = Vec3(bounds.min.x, bounds.min.y, bounds.max.z);
  corners[4] = Vec3(bounds.max.x, bounds.max.y, bounds.min.z);
  corners[5] = Vec3(bounds.max.x, bounds.min.y, bounds.max.z);
  corners[6] = Vec3(bounds.min.x, bounds.max.y, bounds.max.z);
  corners[7] = Vec3(bounds.max.x, bounds.max.y, bounds.max.z);

  for(Size i=0;i<8;i++) {
    Scalar dot = abs(x.dot(center-corners[i]));
    if(dot > maxDot) maxDot = dot;
  }

  Scalar distance = maxDot / tan(this.fovY * 0.4);
  this.position = this.target - posDiff.unit() * distance;
}

function SpliceStandaloneCamera.resetPosition!() {
  this.position = Vec3(30, 20, 40) * 0.6;
  this.target = Vec3(0, 0, 0);
}