require Math;
require InlineDrawing;
require Util;
require Singletons;

object SpliceStandaloneViewport : OGLInlineViewport {
  Integer windowId;
  String filePaths[];
  InlineInstance gridInstance;
  Color bgColor;
};

function SpliceStandaloneViewport() {
  this.bgColor = Color(0.7, 0.7, 0.7);
  this.camera = InlineCamera(50.0 * DEG_TO_RAD, 0.01, 1000.0, false);
  this.camera.xfo.tr = Vec3(30, 20, 40) * 0.6;
  this.camera.xfo.ori.setFromDirectionAndUpvector(this.camera.xfo.tr, Vec3(0, 1, 0));
}

function SpliceStandaloneViewport.addFilePath!(String filePath) {
  this.filePaths.push(filePath);
}

function Boolean SpliceStandaloneViewport.setup!(io DrawContext context) {

  // if(this.performCallback(SpliceStandaloneViewportPhase_Initialize))
  //   return;

  glClearColor(this.bgColor.r, this.bgColor.g, this.bgColor.b, 1);

  glEnable(GL_COLOR_MATERIAL);
  // glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
  // glHint(GL_LINE_SMOOTH_HINT,GL_NICEST);

  glShadeModel(GL_SMOOTH);
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
  glShadeModel(GL_FLAT);
  glEnable(GL_DEPTH_TEST);
  // glEnable(GL_CULL_FACE);

  Integer gl_err = glGetError();
  glFinish();
  if (gl_err != GL_NO_ERROR)
  {
   report("GL error: " + gl_err);
   return false;
  }

  OGLInlineDrawing drawing = OGLInlineDrawing_GetInstance();
  this.gridInstance = drawing.setupSceneGrid('StandaloneGrid', 20, 20, 20, 20, Color(0.05, 0.05, 0.05));

  this.responsibleForSwappingBuffers = false;

  return true;
}

function Boolean SpliceStandaloneViewport.draw!(io DrawContext context) {

  // this.performCallback(SpliceStandaloneViewportPhase_BeforePaint);

  // if(!this.performCallback(SpliceStandaloneViewportPhase_Paint)) {

    glClearColor(this.bgColor.r, this.bgColor.g, this.bgColor.b, 1);

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // Enable the camera to update its possition.
    // based on Camera manipulation.
    this.camera.update();

  // }

  // return this.performCallback(SpliceStandaloneViewportPhase_AfterPaint);
  return true;
}

function Boolean SpliceStandaloneViewport.resize!(Size width, Size height) {

  // if(this.performCallback(SpliceStandaloneViewportPhase_Resize))
  //   return;

  if(!this.parent#resize(width, height))
    return false;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  return true;
}

function SpliceStandaloneViewport.setWireFrame!(Boolean wireFrame) {
  InlineDrawing drawing = OGLInlineDrawing_GetInstance();
  for(Size i=0;i<drawing.getShaderCount();i++) {
    InlineShader shader = drawing.getShader(i);
    if(shader.getName().startsWith('Selection_'))
      continue;
    if(shader.type == OGLWireFrameShader) {
      OGLWireFrameShader wireFrameShader(shader);
      wireFrameShader.setWireFrame(wireFrame);
    }
  }
}

function SpliceStandaloneViewport.toggleGrid!() {
  this.gridInstance.setActive(!this.gridInstance.isActive());
}
